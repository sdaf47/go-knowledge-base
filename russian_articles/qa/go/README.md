# Вопросы по Golang

## Какие в Go есть инструменты для многопоточности?

### 1. Пакет sync
**WaitGroup** — ждет завершения коллекции из одной или нескольких goroutine. 
Количество ожидаемых горутин определяется счетчиком, который заполняется с помощью метода Add в основном потоке(goroutine).
Затем в каждой из goroutine вызывается метод Done, сообщающий о завершении выполнения потока. 
Метод Wait будет блокировать выполнение основоного потока до тех пор, пока все горуты не будут выполнены.

**Mutex** — двоичный семафор, защищающий объект от изменений сразу из нескольких потоков (состояния гонки).
Иными словами, mutex не позволяет нескольким потокам получить доступ к объекту одноврменно.

`sync.Mutex`, `sync.RWMutex`, `sync.Map`


Рекомендации по использвовнию мьютекстов [источник](https://habr.com/post/271789/)
1. Не стоит держать блокировку дольше, чем требуется.
1. Если у функции есть несколько точеек выхода, лучше использовать `defer`.
1. Код, управляющий блокировкой, должен быть учтен при её реализации.
1. Мьютексы должны быть инкапсулированы в пакете, чтобы пользователю библиотеки не пришлось управлять ими самостоятельно.
1. Используйте race-детектор ([пример использования](https://4gophers.ru/articles/konkurentnost-v-go-gonki)).

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var mutex = &sync.Mutex{}
	var wg = sync.WaitGroup{}

	n := 0
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func(num *int) {
		  // с помощью отложенной функции сообщаем, что поток закончил выполнение
			defer wg.Done()
			// переводим mutext в неотмеченное состояние, блокируя доступ для других потоков 
			mutex.Lock()
			// изменяем значение переменно n, переданной по ссылке
			*num++ 
			// переводим mutext в отмеченное состояние, освобождая его для других потоков
			mutex.Unlock() 
		}(&n)
	}
	// блокирем выполнение основого потока до момента, как 1000 потоков сообщат о прекращении работы
	wg.Wait() 

	fmt.Println(n) // 1000
}
```

### 2. Атомарные операции, пакет atomic
**Атомарная операция** — операция, которая либо выполняется целиком, либо не выполняется вовсе; операция, которая не может быть частично выполнена и частично не выполнена.
В том же пакете sync в Go есть пакет atomic, предоставляющий ряд атомарных операций, то есть защищая объекты от попадания в состояние гонки во время их изменения.

Пример:
```go
package main

import (
	"sync"
	"sync/atomic"
)

type intCounter struct {
	int64
}

func (c *intCounter) Add(x int64) {
	atomic.AddInt64(&c.int64, x)
}

func (c *intCounter) Value() (x int64) {
	return c.int64
}

func main() {
	counter := intCounter{0}
	wg := &sync.WaitGroup{}

	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func(no int) {
			defer wg.Done()
			for i := 0; i < 10000; i++ {
				counter.Add(1)
			}
		}(i)
	}

	wg.Wait()
}

```

### Паттерны параллелизма в Golang


## Зачем нужен оператор defer?

## Какие типы данных есть в Go? Как они устроены?

## Зачем нужен оператор defer?

## Что такое пустой interface? Как он устроен?

## Что определяет переменная окружения GOMAXPROCS?
