# Вопросы по Golang

## Что такое goroutine? И чем она отличается от потока системы?
**Горутина** (**goroutine**) — это функция, выполняющаяся конкурентно с другими функциями в том же адресном пространстве.

Пример запуска:
```go
go ParallelFunc()
```

Причиной использования горутин может быть:
- перенос нагрузки на несколько ядер
- асинхронность выполнения функции

Горутины встают в *очередь* и принимают данные из канала по принципу FIFO. 
Соответственно, если запустить несколько горутин, принимающих данные из одного канала,
они будут работать поочереди в одном и том же порядке, определенном единожды.
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ball := 0
	table := make(chan int)

	go timer(table, 1)
	go timer(table, 2)
	go timer(table, 3)
	go timer(table, 4)

	table <- ball
	time.Sleep(time.Microsecond*5)
	<-table
}

func timer(table chan int, t int) {
	for {
		ball := <-table
		fmt.Print(t)
		table <- ball
	}
}

```
Варианты вывода:
```
4213421342134...
4123412341234...
```

Горутина не является системным потоком, чтобы горутины работали на разных ядрах используется переменная окружения `GOMAXPROCS`.
По умолчанию она равна количеству ядер в системе.

Чтобы точно определить, сколько системных потоков использует программа, можно использовать функцию `runtime.NumCPU()`.

[Подробнее о конкуренции и параллелизме в Go](https://habr.com/post/276255/)

## Какие в Go есть инструменты для многопоточности?

### 1. Пакет sync
**WaitGroup** — ждет завершения коллекции из одной или нескольких goroutine. 
Количество ожидаемых горутин определяется счетчиком, который заполняется с помощью метода Add в основном потоке(goroutine).
Затем в каждой из goroutine вызывается метод Done, сообщающий о завершении выполнения потока. 
Метод Wait будет блокировать выполнение основоного потока до тех пор, пока все горуты не будут выполнены.

**Mutex** — двоичный семафор, защищающий объект от изменений сразу из нескольких потоков (состояния гонки).
Иными словами, mutex не позволяет нескольким потокам получить доступ к объекту одноврменно.

`sync.Mutex`, `sync.RWMutex`, `sync.Map`


Рекомендации по использвовнию мьютекстов [источник](https://habr.com/post/271789/)
1. Не стоит держать блокировку дольше, чем требуется.
1. Если у функции есть несколько точеек выхода, лучше использовать `defer`.
1. Код, управляющий блокировкой, должен быть учтен при её реализации.
1. Мьютексы должны быть инкапсулированы в пакете, чтобы пользователю библиотеки не пришлось управлять ими самостоятельно.
1. Используйте race-детектор ([пример использования](https://4gophers.ru/articles/konkurentnost-v-go-gonki)).

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var mutex = &sync.Mutex{}
	var wg = sync.WaitGroup{}

	n := 0
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func(num *int) {
		  // с помощью отложенной функции сообщаем, что поток закончил выполнение
			defer wg.Done()
			// переводим mutext в неотмеченное состояние, блокируя доступ для других потоков 
			mutex.Lock()
			// изменяем значение переменно n, переданной по ссылке
			*num++ 
			// переводим mutext в отмеченное состояние, освобождая его для других потоков
			mutex.Unlock() 
		}(&n)
	}
	// блокирем выполнение основого потока до момента, как 1000 потоков сообщат о прекращении работы
	wg.Wait() 

	fmt.Println(n) // 1000
}
```

### 2. Атомарные операции, пакет atomic
**Атомарная операция** — операция, которая либо выполняется целиком, либо не выполняется вовсе; операция, которая не может быть частично выполнена и частично не выполнена.
В том же пакете sync в Go есть пакет atomic, предоставляющий ряд атомарных операций, то есть защищая объекты от попадания в состояние гонки во время их изменения.

Пример:
```go
package main

import (
	"sync"
	"sync/atomic"
)

type intCounter struct {
	int64
}

func (c *intCounter) Add(x int64) {
	atomic.AddInt64(&c.int64, x)
}

func (c *intCounter) Value() (x int64) {
	return c.int64
}

func main() {
	counter := intCounter{0}
	wg := &sync.WaitGroup{}

	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func(no int) {
			defer wg.Done()
			for i := 0; i < 10000; i++ {
				counter.Add(1)
			}
		}(i)
	}

	wg.Wait()
}

```

### 3. Каналы
**Каналы** — структура данных, которая обеспечивает возможность общения нескольких горутин друг с другом, чтобы синхронизировать их выполнение.

Создание канала
```go
make(chan int)     // небуферизированный канал
make(chan int, 10) // буферизированный канал
```
*Небуферизированный* канал блокирует блокируется до тех пор, пока сообщение не будет обработано.
*Буферизированный канал* может накапливать очередь указанной емкости без блокировки.

## Зачем нужен оператор defer?
**defer** создает отложенный вызов функции. Аргументы, переданные в функцию, будут оценены сразу, 
а сам вызов произойдет после того, как выполнится функция, в теле которой вызывается `defer`.
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("start")
	done := "1"

	// эта функция будет вызыана только после того, как закончит выполнение функция main
	// в выводе будет "1", так как переменная done была переопределена уже после defer
	defer fmt.Println(done)
	done = "2"

	time.Sleep(time.Second * 3)
}
```

## Как перехватить панику?
Для перехвата паники существуте функция `recover()`, которую следует вызывать отложенно с помощью `defer`.
`recover()` — это встроенная функция, которая восстанавливает контроль над паникующей го-процедурой.

```go
package main

import "fmt"

func main() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("main error:", r)
		}
	}()

	i := []int{}

	fmt.Println(i[1])
}

```

## Какие типы данных есть в Go? Как они устроены?
### Числа
#### Целые числа
`uint8` `uint16` `uint32` `uint64` `int8` `int16` `int32` `int64`
int — целове знаково число, uint (unsigned) — целове беззнаковое число.
Для `uint8` также есть псевдоним `byte`, а для `int32` псевдоним `rune`. 
Число возле типа говорит о том, сколько бит использует тип. 

`uint` `int` `uintptr` — машинозависимые типы, их размер определяется архитектурой компьютера.
#### Числа с плавающей точкой
`float32` `float64`
Вещественные типы с одинарной и двойной точностью соответственно.

`complex64` `complex128`
Типа для комплексных чисел

### Строки
Стоки в Go представляют собой структуру, состоящую из ссылки на *массив байт*, а также *длины строки*, определенной типом `int`.
Строка является неизменяемым типом данных, соответственно для любой операции по её изменению создаётся новая строка, и ссылка в структуре заменяется другой.
При использовании оператора `range`, каждый элемент будет представлять собой `rune` (`int32`), длина строки (`len()`) также определяется количеством рун.
Однако, если попытаться получить элемент стркои по ключу `str[key]`, рассчет будет производиться побайтово.

[Как лучше всего работать со строками?](https://habr.com/post/307554/)

### Логические типы
`bool` - `true` или `false`
Для сравнения испоьзуются операторы `=`, `&&`, `||`, `!=`, `<`, `<=`,`>`, `>=`

### Массивы и срезы
`[10]type`
**Массивы** в Go то же самое, что массивы в C, то есть, если у нас есть массив типа `int8`, то его размер будет равен числу элементов.
```go
package main

import (
	"unsafe"
	"fmt"
)

func main() {
	var v [16]int8
	fmt.Println(unsafe.Sizeof(v)) // 16
}
```

`[]type`
**Срез** — это часть массива. Как и массивы, срезы индексируются и имеют длину. В отличии от массивов их длину можно изменить.
Чтобы создать срез не нулевой длины, можно использовать функцию `make`:
```go
    var s = make([]int8, 5)
```
Срезы всегда связаны с каким-нибудь массивом, и не могут стать больше, чем массив.
Устройство срезов представляет собой структуру из 3 членов:
- указатель на массив с данными
- длина среза
- вместимость(*capacity*) — длина массива с данными

Добавлять новые элементы в срез можно с помощью функции `append`.
Если количество элементов переполняет массив с данными, его длина увеличивается вдвое,
создается соответствующий массив и в него копируется всё из старого массива.
Их также можно копировать функцией `copy`.
[Подробнее о срезах](https://sefus.ru/little-go-book-3/)

### Карты
**Карта** (также известна как ассоциативный массив, словарь или хеш-таблица) — это неупорядоченная коллекция пар вида ключ-значение.
*Карта* обязательно должна быть инициализирована перед использованием. 
Для этого используется функция `make`, либо можно объявить карту как составной литерал.
```go
x := make(map[string]int)
y := map[string]int{1,2,3}
```


### Структуры
**Структура** — совокупность переменных, объединенная одним именем.
Структура(`struct`) в Go, как и массивы имеет рамер ровно такой, как сумма всех её членов.

```go
package main

import (
	"unsafe"
	"fmt"
)

func main() {
	var s struct {
		k int8
		v [32]byte
	}
	fmt.Printf(
		"%d + %d = %d",
		unsafe.Sizeof(s.k),
		unsafe.Sizeof(s.v),
		unsafe.Sizeof(s),
	) // 1 + 32 = 33
}
```

### interface{}
`interface` — структура, поределяющая поведение других структур.
Содержит ссылку на реализованную структуру, а также ссылку на таблицу с соответствием методов.

[Источник](https://habr.com/post/276981/)

Пример:
```go
package main

// интерфейс, определяющий поведение для гоферов
type Gopher interface {
	Go()
}
// реализация гофера
type gopher struct {
	isGoing bool
}

func (g *gopher) Go() {
	g.isGoing = true
}

func main() {
	g := &gopher{}

	GoMyGopher(g)
}
// функция получает объект, имплементирующий интерфейс Gopher
func GoMyGopher(g Gopher) {
	g.Go()
}
```

[Подробнее о runtime в Go](http://m0sth8.github.io/runtime-1)

## Что такое пустой interface? Как он устроен?
Пустой интерфейс ассоциирует объект с пустой таблицей itable, то есть ничем не ограничивает структуру, которая будет передана туда, где ожидается сам `interface{}`.

## Как тестируется производительность в Go?
[Подробный разбор бенчмарков](https://habr.com/post/268585/)

## Паттерны проектирования в Go
В [этом репозитории](https://github.com/AlexanderGrom/go-patterns) есть примеры реализации паттернов ООП на Golang.
